Parts placed inside [] are optional

<#####################################################################################################>

Each program is divided into (modules), which are basically files
Each file is a module of its own

<#####################################################################################################>

# Comments are like this

<#####################################################################################################>

Semi-colons are optional

<#####################################################################################################>

Primitive data types:
int     =>  Signed/Unsigned integers
real    =>  Real number
string  =>  Anything inside ""
bool    =>  True or False
array   =>  static size single-type-data containers, they hold multiple values of the same type

<#####################################################################################################>

Variables and Constants:
define variable_name: type [ := value [ ; ] ]
define const_name: type [ := value [ ; ] ]

type: (var) or (const) not both, then a primitive or user-defined type, and then the optional & reference indicator

<#####################################################################################################>

So we can do these things:
define x: var int := 123;
define y: const string := "Hello world!";
define xyz: const real := 123.e+234
define _zyfe19334: var real := -0.3892 + 32.0 * 3344;
define x: var array[10:int] := [0, 1, 2, 3, 4, 5, 6, 8, 9]
define tree: const array[2:string] := ["branch 0", "branch 1"];
define right: const bool = true;
define go: var bool = false

And as usual, this is how you index arrays:
define x: const [4:string] = ['false', 'False', 'True', 'true']
x[0] is 'false'
x[1] is 'False'
And so on

Reference:
Pointer to an actual variable/constant, mutating reference mutates the pointed variable/constant
define x: var int = -13;
define x_ref: var int& = ref_of x
x_ref = 123; # now (x) will also take value 123

<#####################################################################################################>

This language is indented-blocked
Blocks of code are denoted by their indentation level

<#####################################################################################################>

Simple I/O:
write(var0, var1, ..., varn)
read(&var0, &var1, ..., &varn)

<#####################################################################################################>

This &var0 notations is for (references), which are simply actual variables not just values
So things like this are NOT allowed:
read(7);
But this is allowed:
var x: int = 0
read(&x)

<#####################################################################################################>

Block statements:
Function
If
For
While

ALL BLOCK STATEMENTS MUST HAVE (end "something") to denote their end

<#####################################################################################################>

FUNCTIONS:
fn function_name(parameters_list): return_type
    body
end "anything you like here"

parameters_list can be empty

<#####################################################################################################>

IF STATEMENT:
If condition0
    body
[
else if condition1
    body
.
.
.
else if condition_n
    body
]
[
else:
    body
]
end "anything"

<#####################################################################################################>

FOR STATEMENT:
for name in array_variable
    body
end "jfskjsgknkdngln"

<#####################################################################################################>

WHILE STATEMENT:
while condition
    body
end "while condition statement"

<#####################################################################################################>

EMPTY BLOCK:
fn func()
    pass
end "func()"

<#####################################################################################################>

We also have the all usual (break), (continue) and (return) statements

<#####################################################################################################>

Operators: Arthimetic or Logical or Assignment_Operator
Arthimetic: Real_Number_Operator or Integer_Operator
Real_Number_Operator: + - * / 
Integer_Operator: ~:not &:and |:or ^:xor >>:right_shift <<:left_shift ++ --
Logical: == != < <= > >= and not or
Assignment_Operator:
:= = += -= *= /= ~= &= |= ^= >>= <<=
Also the reference operator: &
