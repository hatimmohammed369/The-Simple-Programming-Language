Parts placed inside [] are optional

<#####################################################################################################>

Each program is divided into (modules), which are basically files
Each file is a module of its own

<#####################################################################################################>

Semi-colons are optional

<#####################################################################################################>

Primitive data types:
int     =>  Signed/Unsigned integers
real    =>  Real number
string  =>  Anything inside ""
bool    =>  True or False
array   =>  static size single-type-data containers, they hold multiple values of the same type

<#####################################################################################################>

Variables and Constants:
variable_name: type [ := value [ ; ] ]
const const_name: type [ := value [ ; ] ]

<#####################################################################################################>

So we can do these things:
x: int := 123;
const y: string := "Hello world!";
const xyz: real := 123.e+234
_zyfe19334: real := -0.3892 + 32.0 * 3344;
x: array[10:int] := [0, 1, 2, 3, 4, 5, 6, 8, 9]
const tree: array[2:string] := ["branch 0", "branch 1"];

<#####################################################################################################>

This language is indented-blocked
Blocks of code are denoted by their indentation level

<#####################################################################################################>

Simple I/O:
write(var0, var1, ..., varn)
read(&var0, &var1, ..., &varn)

<#####################################################################################################>

This &var0 notations is for (references), which are simply actual variables not just values
So things like this are NOT allowed:
read(7);
But this is allowed:
x: int = 0
read(&x)

<#####################################################################################################>

Block statements:
Function
If
For
While

ALL BLOCK STATEMENTS MUST HAVE (end "something") to denote their end

<#####################################################################################################>

FUNCTIONS:
fn function_name(parameters_list): return_type
    body
end "anything you like here"

parameters_list can be empty

<#####################################################################################################>

IF STATEMENT:
If condition0
    body
[
else if condition1
    body
.
.
.
else if condition_n
    body
]
[
else:
    body
]
end "anything"

<#####################################################################################################>

FOR STATEMENT:
for name in array_variable
    body
end "jfskjsgknkdngln"

<#####################################################################################################>

WHILE STATEMENT:
while condition
    body
end "while condition statement"

<#####################################################################################################>

EMPTY BLOCK:
fn func()
    pass
end "func()"

<#####################################################################################################>

We also have the all usual (break), (continue) and (return) statements

<#####################################################################################################>

Operators: Arthimetic or Logical or Assignment_Operator
Arthimetic: Real_Number_Operator or Integer_Operator
Real_Number_Operator: + - * / 
Integer_Operator: ~:not &:and |:or ^:xor >>:right_shift <<:left_shift ++ --
Logical: == != < <= > >= and not or
Assignment_Operator:
:= = += -= *= /= ~= &= |= ^= >>= <<=
